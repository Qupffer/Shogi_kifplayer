<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KIF Viewer (simple)</title>
  <style>
    :root { --sq: 40px; }
    body { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Sans", "Noto Sans JP", "Segoe UI", sans-serif; margin: 16px; }
    h1 { font-size: 18px; margin: 0 0 12px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
    .panel { border: 1px solid #ddd; border-radius: 10px; padding: 12px; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button { padding: 8px 10px; border-radius: 8px; border: 1px solid #bbb; background: #fff; cursor: pointer; }
    button:active { transform: translateY(1px); }
    input[type="range"] { width: min(520px, 90vw); }
    textarea { width: min(520px, 90vw); height: 140px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .meta { font-size: 12px; color: #444; white-space: pre-wrap; }
    .hands { display: grid; gap: 6px; font-size: 14px; }
    .handline { display: flex; gap: 8px; flex-wrap: wrap; align-items: baseline; }
    .handtitle { font-weight: 700; min-width: 3.2em; }
    .handpiece { padding: 2px 6px; border: 1px solid #ddd; border-radius: 999px; background: #fafafa; }
    .boardwrap { display: flex; flex-direction: column; gap: 8px; }
    table.board { border-collapse: collapse; user-select: none; }
    table.board td { width: var(--sq); height: var(--sq); border: 1px solid #444; text-align: center; vertical-align: middle; font-size: 18px; position: relative; }
    table.board td .gote { display: inline-block; transform: rotate(180deg); }
    table.board td .hint { position: absolute; left: 4px; top: 2px; font-size: 10px; color: #999; }
    .movelist { max-height: calc(var(--sq) * 9 + 60px); overflow: auto; width: min(520px, 90vw); }
    .movelist ol { margin: 0; padding-left: 22px; }
    .movelist li { padding: 3px 6px; border-radius: 6px; cursor: pointer; }
    .movelist li:hover { background: #f4f4f4; }
    .movelist li.active { background: #e8f0ff; }
    .small { font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <h1>簡易 棋譜再生（KIF）</h1>

  <div class="row">
    <div class="panel">
      <div class="controls">
        <input id="file" type="file" accept=".kif,.kifu,.txt" />
        <button id="btnSample" title="同じリポジトリに piyo_prev_game.kif を置いた場合">サンプル読込</button>
      </div>
      <div style="margin-top:10px">
        <div class="small">ファイルが面倒なら、ここにKIFを貼って「貼付読込」でもOK。</div>
        <textarea id="kifText" placeholder="ここにKIFを貼り付け"></textarea>
        <div class="controls" style="margin-top:8px">
          <button id="btnLoadText">貼付読込</button>
          <button id="btnReset">初期局面</button>
        </div>
      </div>
      <div class="meta" id="meta"></div>
    </div>

    <div class="panel boardwrap">
      <div class="hands" id="hands"></div>

      <table class="board" id="board"></table>

      <div class="controls">
        <button id="btnFirst">|&lt;</button>
        <button id="btnPrev">&lt;</button>
        <button id="btnNext">&gt;</button>
        <button id="btnLast">&gt;|</button>
      </div>
      <div class="controls">
        <input id="slider" type="range" min="0" max="0" value="0" />
        <span id="plyLabel" class="small">0手目</span>
      </div>
      <div class="small" id="moveLabel"></div>
    </div>

    <div class="panel movelist">
      <div class="small" style="margin-bottom:6px">手順（タップで移動）</div>
      <ol id="moves"></ol>
    </div>
  </div>

<script>
(() => {
  // ---- Helpers: text decode (cp932/shift-jis)
  function decodeKif(buf) {
    const encs = ["shift-jis", "cp932", "utf-8"];
    for (const enc of encs) {
      try {
        const td = new TextDecoder(enc, { fatal: false });
        const txt = td.decode(buf);
        if (txt && txt.includes("手数")) return txt; // だいたいKIFっぽい合図
        // 失敗判定はゆるめに
        if (txt && txt.length > 20) return txt;
      } catch (_) {}
    }
    // 最後の手段
    return new TextDecoder("utf-8").decode(buf);
  }

  // ---- Shogi representation
  // Coordinates: file 1..9 (右から左へではなく「数字そのまま」), rank 1..9 (上から下)
  // Display: rank 1 at top, file 9 on left (一般的な将棋盤表示)
  const PIECE = {
    P:"歩", L:"香", N:"桂", S:"銀", G:"金", B:"角", R:"飛", K:"玉",
    pP:"と", pL:"杏", pN:"圭", pS:"全", pB:"馬", pR:"龍",
  };
  function promote(kind){ // base -> promoted flag representation
    if (kind === "P") return "pP";
    if (kind === "L") return "pL";
    if (kind === "N") return "pN";
    if (kind === "S") return "pS";
    if (kind === "B") return "pB";
    if (kind === "R") return "pR";
    return kind;
  }
  function unpromote(kind){
    if (kind === "pP") return "P";
    if (kind === "pL") return "L";
    if (kind === "pN") return "N";
    if (kind === "pS") return "S";
    if (kind === "pB") return "B";
    if (kind === "pR") return "R";
    return kind;
  }
  function isPromoted(kind){ return kind.startsWith("p"); }
  function sideName(s){ return s === "b" ? "先手" : "後手"; }

  function emptyBoard() {
    const b = Array.from({length:10}, () => Array(10).fill(null));
    return b;
  }

  function initStartpos() {
    const b = emptyBoard();
    // rank 1..9, file 1..9
    // SFEN: lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL
    // rank1 (top) is gote pieces, rank9 bottom is sente pieces
    // place: file9..1 in each rank
    const ranks = [
      "lnsgkgsnl",
      "1r5b1",
      "ppppppppp",
      "9",
      "9",
      "9",
      "PPPPPPPPP",
      "1B5R1",
      "LNSGKGSNL",
    ];
    for (let r=1; r<=9; r++){
      const row = ranks[r-1];
      let f = 9;
      for (let i=0; i<row.length; i++){
        const ch = row[i];
        if (/\d/.test(ch)) { f -= Number(ch); continue; }
        const side = (ch === ch.toUpperCase()) ? "b" : "w";
        const pc = ch.toUpperCase();
        const kind = pc === "P" ? "P" :
                     pc === "L" ? "L" :
                     pc === "N" ? "N" :
                     pc === "S" ? "S" :
                     pc === "G" ? "G" :
                     pc === "B" ? "B" :
                     pc === "R" ? "R" : "K";
        b[r][f] = { side, kind };
        f -= 1;
      }
    }
    const hands = { b:{}, w:{} };
    return { board:b, hands, stm:"b", lastTo:null };
  }

  function clonePos(pos){
    const b2 = emptyBoard();
    for (let r=1;r<=9;r++) for (let f=1;f<=9;f++){
      const p = pos.board[r][f];
      b2[r][f] = p ? { side:p.side, kind:p.kind } : null;
    }
    const h2 = { b:{}, w:{} };
    for (const s of ["b","w"]) {
      for (const k in pos.hands[s]) h2[s][k] = pos.hands[s][k];
    }
    return { board:b2, hands:h2, stm:pos.stm, lastTo: pos.lastTo ? { ...pos.lastTo } : null };
  }

  // ---- KIF parsing
  const FW_DIGITS = "０１２３４５６７８９";
  const KAN_RANK = { "一":1,"二":2,"三":3,"四":4,"五":5,"六":6,"七":7,"八":8,"九":9 };
  function parseDest(s, lastTo) {
    s = s.trim();
    if (s.startsWith("同")) {
      if (!lastTo) return null;
      return { f:lastTo.f, r:lastTo.r, rest: s.replace(/^同\s*/, "") };
    }
    const fch = s[0], rch = s[1];
    const f = FW_DIGITS.indexOf(fch);
    const r = KAN_RANK[rch];
    if (!(f>=1 && f<=9 && r>=1 && r<=9)) return null;
    return { f, r, rest: s.slice(2) };
  }

  function parsePieceAndFlags(rest) {
    // strip spaces
    rest = rest.replace(/\s+/g, "");
    // flags
    let isDrop = rest.includes("打");
    rest = rest.replace(/打/g, "");
    let forceNoProm = rest.includes("不成");
    rest = rest.replace(/不成/g, "");
    // relative hints (ignore)
    rest = rest.replace(/[右左直寄引上行]/g, "");

    // piece tokens (longest first)
    const tokens = [
      ["成銀","pS"], ["成桂","pN"], ["成香","pL"], ["成歩","pP"],
      ["と","pP"], ["馬","pB"], ["龍","pR"], ["竜","pR"],
      ["飛","R"], ["角","B"], ["金","G"], ["銀","S"], ["桂","N"], ["香","L"], ["歩","P"], ["玉","K"], ["王","K"],
    ];
    let kind = null;
    for (const [t,k] of tokens){
      if (rest.startsWith(t)) { kind = k; rest = rest.slice(t.length); break; }
    }
    if (!kind) return null;

    // "角成" like promotion suffix
    let prom = false;
    if (!forceNoProm && rest.startsWith("成")) { prom = true; rest = rest.slice(1); }
    if (forceNoProm) prom = false;

    // already promoted kind
    if (isPromoted(kind)) prom = false; // already promoted

    return { kind, prom, isDrop };
  }

  function parseMoves(kifText) {
    const lines = kifText.split(/\r?\n/);
    const meta = {};
    const moves = [];
    let inMoves = false;

    for (const line0 of lines) {
      const line = line0.trimEnd();
      if (!line) continue;

      if (line.includes("手数----指手")) { inMoves = true; continue; }
      if (!inMoves) {
        // meta: "先手：..." etc
        const m = line.match(/^([^：]+)：(.*)$/);
        if (m) meta[m[1].trim()] = m[2].trim();
        continue;
      }

      if (line.startsWith("*")) continue; // comment
      // move line example:
      //  11 ８七歩打 ( 0:01/00:00:06)
      //   1 ２六歩(27)( 0:01/00:00:01)
      const m1 = line.match(/^\s*(\d+)\s+(.+?)\((\d\d)\)\s*\(/);
      if (m1) {
        const no = Number(m1[1]);
        const mvStr = m1[2].trim();
        const from = m1[3]; // "27"
        moves.push({ no, mvStr, from, raw: line });
        continue;
      }
      const m2 = line.match(/^\s*(\d+)\s+(.+?)\s*\(/);
      if (m2) {
        const no = Number(m2[1]);
        const mvStr = m2[2].trim();
        moves.push({ no, mvStr, from: null, raw: line });
        continue;
      }
      // 終局行などは無視
    }
    return { meta, moves };
  }

  // ---- Move legality (simple) for fallback when from is missing and not drop
  function dir(side){ return side === "b" ? -1 : 1; }
  function inside(f,r){ return f>=1 && f<=9 && r>=1 && r<=9; }

  function canReach(board, side, kind, fromF, fromR, toF, toR) {
    const df = toF - fromF;
    const dr = toR - fromR;
    const d = dir(side);

    function clearLine(stepF, stepR) {
      let f = fromF + stepF, r = fromR + stepR;
      while (f !== toF || r !== toR) {
        if (!inside(f,r)) return false;
        if (board[r][f]) return false;
        f += stepF; r += stepR;
      }
      return true;
    }

    // promoted piece movement (except pB/pR special)
    if (kind === "pP" || kind === "pL" || kind === "pN" || kind === "pS") {
      // Gold-like
      const ok = (
        (df===0 && dr===d) ||
        (Math.abs(df)===1 && dr===d) ||
        (Math.abs(df)===1 && dr===0) ||
        (df===0 && dr===-d)
      );
      return ok;
    }

    if (kind === "G") {
      const ok = (
        (df===0 && dr===d) ||
        (Math.abs(df)===1 && dr===d) ||
        (Math.abs(df)===1 && dr===0) ||
        (df===0 && dr===-d)
      );
      return ok;
    }
    if (kind === "S") {
      const ok = (
        (df===0 && dr===d) ||
        (Math.abs(df)===1 && dr===d) ||
        (Math.abs(df)===1 && dr===-d)
      );
      return ok;
    }
    if (kind === "K") return Math.abs(df)<=1 && Math.abs(dr)<=1 && !(df===0 && dr===0);
    if (kind === "P") return df===0 && dr===d;
    if (kind === "N") return (Math.abs(df)===1 && dr===2*d);
    if (kind === "L") {
      if (df!==0) return false;
      const stepR = d;
      // must move forward
      if ((toR-fromR)*d <= 0) return false;
      return clearLine(0, stepR);
    }
    if (kind === "B" || kind === "pB") {
      if (Math.abs(df) === Math.abs(dr) && df!==0) {
        const stepF = df>0?1:-1;
        const stepR = dr>0?1:-1;
        if (!clearLine(stepF, stepR)) return false;
        return true;
      }
      if (kind === "pB") {
        // king steps orthogonal
        return (Math.abs(df)===1 && dr===0) || (Math.abs(dr)===1 && df===0);
      }
      return false;
    }
    if (kind === "R" || kind === "pR") {
      if ((df===0 && dr!==0) || (dr===0 && df!==0)) {
        const stepF = df===0 ? 0 : (df>0?1:-1);
        const stepR = dr===0 ? 0 : (dr>0?1:-1);
        if (!clearLine(stepF, stepR)) return false;
        return true;
      }
      if (kind === "pR") {
        // king steps diagonal
        return Math.abs(df)===1 && Math.abs(dr)===1;
      }
      return false;
    }
    return false;
  }

  function applyMove(pos, mvObj) {
    const next = clonePos(pos);
    const side = next.stm;

    // parse destination
    const destParsed = parseDest(mvObj.mvStr, next.lastTo);
    if (!destParsed) return { next, ok:false, reason:"dest parse failed" };
    const { f:toF, r:toR, rest } = destParsed;

    const pf = parsePieceAndFlags(rest);
    if (!pf) return { next, ok:false, reason:"piece parse failed" };

    let { kind, prom, isDrop } = pf;

    // capture
    const target = next.board[toR][toF];
    if (target && target.side !== side) {
      const capBase = unpromote(target.kind);
      next.hands[side][capBase] = (next.hands[side][capBase] || 0) + 1;
    }

    // decide from
    let fromF = null, fromR = null;
    if (!isDrop && mvObj.from) {
      fromF = Number(mvObj.from[0]);
      fromR = Number(mvObj.from[1]);
    }

    if (isDrop) {
      // consume from hand
      const base = unpromote(kind); // drop is always unpromoted in rules, but KIF already gives base typically
      if ((next.hands[side][base] || 0) <= 0) {
        // hand count missing: still allow (viewer tolerance)
      } else {
        next.hands[side][base] -= 1;
      }
      next.board[toR][toF] = { side, kind: base }; // drop unpromoted
    } else {
      // if from missing, infer a candidate by searching board
      let piece = null;
      if (fromF && fromR) piece = next.board[fromR][fromF];

      if (!piece || piece.side !== side) {
        // infer
        const wantBase = unpromote(kind);
        let found = null;
        for (let r=1;r<=9;r++) for (let f=1;f<=9;f++){
          const p = next.board[r][f];
          if (!p || p.side !== side) continue;
          // piece type must match base or promoted-kind; allow because KIF piece notation is destination piece, not source
          if (unpromote(p.kind) !== wantBase) continue;
          if (canReach(next.board, side, p.kind, f, r, toF, toR)) { found = {f,r,p}; break; }
        }
        if (found) {
          fromF = found.f; fromR = found.r; piece = found.p;
        } else {
          // as last resort: just place something (viewer tolerance)
          piece = { side, kind: wantBase };
          fromF = null; fromR = null;
        }
      }

      if (fromF && fromR) next.board[fromR][fromF] = null;

      let movedKind = piece.kind;
      if (prom) movedKind = promote(unpromote(movedKind)); // promote from base
      next.board[toR][toF] = { side, kind: movedKind };
    }

    next.lastTo = { f:toF, r:toR };
    next.stm = (side === "b") ? "w" : "b";
    return { next, ok:true, reason:null };
  }

  // ---- UI state
  let kif = null;
  let positions = []; // positions[ply] = position after ply moves (ply0 = start)
  let curPly = 0;

  // elements
  const elBoard = document.getElementById("board");
  const elHands = document.getElementById("hands");
  const elMoves = document.getElementById("moves");
  const elSlider = document.getElementById("slider");
  const elPlyLabel = document.getElementById("plyLabel");
  const elMoveLabel = document.getElementById("moveLabel");
  const elMeta = document.getElementById("meta");
  const elFile = document.getElementById("file");
  const elKifText = document.getElementById("kifText");

  function renderBoard(pos) {
    // table with ranks 1..9 top->bottom, files 9..1 left->right
    elBoard.innerHTML = "";
    for (let r=1; r<=9; r++) {
      const tr = document.createElement("tr");
      for (let f=9; f>=1; f--) {
        const td = document.createElement("td");
        const p = pos.board[r][f];
        if (p) {
          const span = document.createElement("span");
          const k = p.kind;
          const base = unpromote(k);
          const label = (isPromoted(k) ? PIECE[k] : PIECE[base]) || "?";
          span.textContent = label;
          if (p.side === "w") span.className = "gote";
          td.appendChild(span);
        }
        tr.appendChild(td);
      }
      elBoard.appendChild(tr);
    }
  }

  function renderHands(pos) {
    function fmtHand(side){
      const order = ["R","B","G","S","N","L","P"];
      const parts = [];
      for (const k of order) {
        const n = pos.hands[side][k] || 0;
        if (n>0) parts.push(`<span class="handpiece">${PIECE[k]}×${n}</span>`);
      }
      return parts.length ? parts.join(" ") : `<span class="small">なし</span>`;
    }
    elHands.innerHTML = `
      <div class="handline"><span class="handtitle">後手</span> ${fmtHand("w")}</div>
      <div class="handline"><span class="handtitle">先手</span> ${fmtHand("b")}</div>
    `;
  }

  function renderMovelist() {
    elMoves.innerHTML = "";
    kif.moves.forEach((m, idx) => {
      const li = document.createElement("li");
      li.textContent = `${m.no}. ${m.mvStr}${m.from ? " ("+m.from+")" : ""}`;
      li.dataset.ply = String(idx+1);
      li.addEventListener("click", () => setPly(idx+1));
      elMoves.appendChild(li);
    });
  }

  function highlightMovelist() {
    const lis = elMoves.querySelectorAll("li");
    lis.forEach(li => li.classList.remove("active"));
    if (curPly >= 1) {
      const li = elMoves.querySelector(`li[data-ply="${curPly}"]`);
      if (li) {
        li.classList.add("active");
        li.scrollIntoView({ block:"nearest" });
      }
    }
  }

  function setPly(ply) {
    ply = Math.max(0, Math.min(ply, positions.length-1));
    curPly = ply;
    elSlider.value = String(ply);
    elPlyLabel.textContent = `${ply}手目`;
    const pos = positions[ply];
    renderBoard(pos);
    renderHands(pos);
    highlightMovelist();

    if (ply === 0) {
      elMoveLabel.textContent = "初期局面";
    } else {
      const m = kif.moves[ply-1];
      elMoveLabel.textContent = `${m.no}. ${m.mvStr}${m.from ? " ("+m.from+")" : ""}`;
    }
  }

  function buildPositions() {
    positions = [];
    let pos = initStartpos();
    positions.push(clonePos(pos));
    for (const m of kif.moves) {
      const res = applyMove(pos, m);
      pos = res.next;
      positions.push(clonePos(pos));
    }
    elSlider.max = String(Math.max(0, positions.length-1));
    renderMovelist();
    setPly(0);
  }

  function setMeta(meta) {
    const keys = ["棋戦","戦型","開始日時","終了日時","手合割","先手","後手"];
    let out = "";
    for (const k of keys) if (meta[k]) out += `${k}：${meta[k]}\n`;
    elMeta.textContent = out.trim();
  }

  function loadKifText(text) {
    kif = parseMoves(text);
    setMeta(kif.meta);
    buildPositions();
  }

  // buttons
  document.getElementById("btnFirst").addEventListener("click", () => setPly(0));
  document.getElementById("btnPrev").addEventListener("click", () => setPly(curPly-1));
  document.getElementById("btnNext").addEventListener("click", () => setPly(curPly+1));
  document.getElementById("btnLast").addEventListener("click", () => setPly(positions.length-1));

  elSlider.addEventListener("input", (e) => setPly(Number(e.target.value)));

  document.getElementById("btnReset").addEventListener("click", () => {
    if (!kif) {
      kif = { meta:{}, moves:[] };
      positions = [initStartpos()];
      elSlider.max = "0";
    }
    setPly(0);
  });

  document.getElementById("btnLoadText").addEventListener("click", () => {
    const t = elKifText.value;
    if (!t.trim()) return;
    loadKifText(t);
  });

  elFile.addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const buf = await f.arrayBuffer();
    const text = decodeKif(buf);
    elKifText.value = text;
    loadKifText(text);
  });

  document.getElementById("btnSample").addEventListener("click", async () => {
    try {
      const res = await fetch("./piyo_prev_game.kif", { cache: "no-store" });
      if (!res.ok) throw new Error("fetch failed");
      const buf = await res.arrayBuffer();
      const text = decodeKif(buf);
      elKifText.value = text;
      loadKifText(text);
    } catch (e) {
      alert("サンプルが見つからないわ。リポジトリ直下に piyo_prev_game.kif を置いてね。");
    }
  });

  // initial empty render
  kif = { meta:{}, moves:[] };
  positions = [initStartpos()];
  renderBoard(positions[0]);
  renderHands(positions[0]);
})();
</script>
</body>
</html>
