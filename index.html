<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>KIF Viewer (branch)</title>
  <style>
    :root{
      --sq: clamp(28px, 8.2vw, 44px);
      --board-bg: #f2b10a;       /* 盤っぽい黄 */
      --line: #111;             /* 罫線 */
      --panel: #ffffff;
      --muted: #666;
      --accent: #1a73e8;
    }
    html, body { height: 100%; }
    body{
      margin: 0;
      font-family: -apple-system,BlinkMacSystemFont,"Hiragino Sans","Noto Sans JP","Segoe UI",sans-serif;
      background: #fff;
      overflow: hidden; /* iframe内で内部スクロールに寄せる */
    }

    header{
      padding: 12px 14px;
      border-bottom: 1px solid #e5e5e5;
      display:flex; gap:10px; align-items: baseline; flex-wrap: wrap;
    }
    header h1{ font-size: 16px; margin: 0; }
    header .small{ font-size: 12px; color: var(--muted); }

    .app{
      height: calc(100% - 49px);
      display: grid;
      grid-template-columns: 1fr;
      overflow: hidden;
    }

    /* 3カラム(広い時) / 1カラム(狭い時) */
    .row{
      height: 100%;
      display: grid;
      grid-template-columns: 360px 1fr 360px;
      gap: 12px;
      padding: 12px;
      overflow: hidden;
      box-sizing: border-box;
    }
    @media (max-width: 980px){
      .row{ grid-template-columns: 1fr; }
    }

    .panel{
      background: var(--panel);
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 12px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .controls{
      display:flex; gap:8px; flex-wrap: wrap; align-items: center;
    }
    button{
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #bbb;
      background: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    button:active{ transform: translateY(1px); }
    input[type="range"]{ width: min(520px, 92vw); }
    textarea{
      width: 100%;
      height: 140px;
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;
      font-size: 12px;
      box-sizing: border-box;
    }
    .meta{ font-size: 12px; color:#333; white-space: pre-wrap; margin-top: 8px; }
    .small{ font-size: 12px; color: var(--muted); }

    /* --- Board area --- */
    .boardArea{
      display:flex;
      flex-direction: column;
      gap: 10px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid #ddd;
      background: #fff;
    }

    .boardFrame{
      display: grid;
      grid-template-columns: 28px auto 36px;
      grid-template-rows: 26px auto;
      gap: 6px;
      align-items: start;
      justify-content: start;
    }

    .topFiles{
      grid-column: 2 / 3;
      grid-row: 1 / 2;
      display: grid;
      grid-template-columns: repeat(9, var(--sq));
      justify-content: start;
      font-family: "Hiragino Mincho ProN","Yu Mincho","Noto Serif JP",serif;
      font-size: 14px;
      color: #111;
      letter-spacing: 0.5px;
    }
    .topFiles div{ text-align:center; }

    .leftLabel{
      grid-column: 1 / 2;
      grid-row: 2 / 3;
      writing-mode: vertical-rl;
      text-orientation: upright;
      font-family: "Hiragino Mincho ProN","Yu Mincho","Noto Serif JP",serif;
      font-size: 18px;
      color:#111;
      padding-top: 2px;
    }

    .rightRanks{
      grid-column: 3 / 4;
      grid-row: 2 / 3;
      display: grid;
      grid-template-rows: repeat(9, var(--sq));
      justify-content: start;
      font-family: "Hiragino Mincho ProN","Yu Mincho","Noto Serif JP",serif;
      font-size: 16px;
      color:#111;
    }
    .rightRanks div{ display:flex; align-items:center; justify-content:center; }

    table.board{
      grid-column: 2 / 3;
      grid-row: 2 / 3;
      border-collapse: collapse;
      user-select: none;
      background: var(--board-bg);
      border: 3px solid var(--line);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
    }
    table.board td{
      width: var(--sq);
      height: var(--sq);
      border: 2px solid var(--line);
      text-align: center;
      vertical-align: middle;
      font-size: calc(var(--sq) * 0.55);
      position: relative;
      font-family: "Hiragino Mincho ProN","Yu Mincho","Noto Serif JP",serif;
      color: #111;
    }
    table.board td .gote{ display:inline-block; transform: rotate(180deg); }

    /* 持ち駒・手番（右側の黒帯っぽい） */
    .sideBar{
      display:flex;
      gap: 10px;
      align-items: stretch;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .turnBadge{
      background:#111;
      color:#fff;
      border-radius: 10px;
      padding: 10px 12px;
      display:flex;
      gap: 10px;
      align-items:center;
      min-width: 170px;
    }
    .turnBadge .mark{
      width: 28px; height: 28px;
      border-radius: 8px;
      display:flex; align-items:center; justify-content:center;
      background:#000;
      border: 1px solid rgba(255,255,255,0.35);
      font-size: 18px;
      line-height: 1;
    }
    .turnBadge .txt{
      display:flex; flex-direction: column;
      gap: 2px;
      font-family: "Hiragino Mincho ProN","Yu Mincho","Noto Serif JP",serif;
    }
    .turnBadge .txt .who{ font-size: 14px; }
    .turnBadge .txt .hold{ font-size: 13px; opacity: 0.95; }

    .navRow{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
    }

    /* 分岐選択UI */
    .branchBox{
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 10px;
      background:#fafafa;
    }
    .branchTitle{ font-weight: 700; font-size: 13px; margin-bottom: 6px; }
    .branchList{ display:flex; flex-direction: column; gap: 6px; }
    .branchBtn{
      text-align:left;
      width:100%;
      border: 1px solid #cfcfcf;
      background:#fff;
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 13px;
    }
    .branchBtn.active{
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(26,115,232,0.18);
    }

    /* 手順リスト */
    .movelist ol{ margin:0; padding-left: 22px; }
    .movelist li{ padding: 4px 6px; border-radius: 8px; cursor:pointer; }
    .movelist li:hover{ background:#f4f4f4; }
    .movelist li.active{ background:#e8f0ff; }

    .footerNote{
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
      line-height: 1.35;
    }
    a.link{ color: var(--accent); text-decoration: none; }
    a.link:hover{ text-decoration: underline; }
  </style>
</head>
<body>
  <header>
    <h1>棋譜再生（KIF / 分岐対応）</h1>
    <div class="small">Notion埋め込みで小さい場合は、埋め込み内スクロール or 右上の「開く」で全画面表示。</div>
  </header>

  <div class="app">
    <div class="row">

      <!-- Left: loader -->
      <div class="panel">
        <div class="controls">
          <input id="file" type="file" accept=".kif,.kifu,.txt" />
          <button id="btnSample" title="同じ場所に piyo_prev_game.kif を置いた場合">サンプル</button>
        </div>

        <div style="margin-top:10px">
          <div class="small">ファイルが面倒なら、ここにKIFを貼って「貼付読込」でもOK。</div>
          <textarea id="kifText" placeholder="ここにKIFを貼り付け"></textarea>
          <div class="controls" style="margin-top:8px">
            <button id="btnLoadText">貼付読込</button>
            <button id="btnReset">初期局面</button>
          </div>
        </div>

        <div class="meta" id="meta"></div>

        <div class="footerNote">
          ・分岐の多い棋譜は、本譜だけ読み込み、必要な変化だけ選択して辿ります。<br>
          ・GitHub Pages で公開して Notion にURLを埋め込むのが安定です。
        </div>
      </div>

      <!-- Middle: board -->
      <div class="boardArea" id="boardArea">
        <div class="sideBar">
          <div class="turnBadge" id="turnBadge">
            <div class="mark" id="turnMark">☗</div>
            <div class="txt">
              <div class="who" id="turnWho">先手番</div>
              <div class="hold" id="turnHold">（先手：なし）</div>
            </div>
          </div>

          <div class="navRow">
            <button id="btnFirst">|&lt;</button>
            <button id="btnPrev">&lt;</button>
            <button id="btnNext">&gt;</button>
            <button id="btnLast">&gt;|</button>
          </div>
        </div>

        <div class="navRow">
          <input id="slider" type="range" min="0" max="0" value="0" />
          <span id="plyLabel" class="small">0手目</span>
        </div>
        <div class="small" id="moveLabel">初期局面</div>

        <div id="branchUI" class="branchBox" style="display:none">
          <div class="branchTitle">この局面の変化</div>
          <div class="branchList" id="branchList"></div>
          <div class="small" style="margin-top:6px" id="branchHint"></div>
        </div>

        <div class="boardFrame">
          <div class="topFiles" id="topFiles"></div>
          <div class="leftLabel">将棋</div>
          <table class="board" id="board"></table>
          <div class="rightRanks" id="rightRanks"></div>
        </div>
      </div>

      <!-- Right: movelist -->
      <div class="panel movelist">
        <div class="controls" style="justify-content:space-between; gap:10px;">
          <div class="small">手順（タップで移動）</div>
          <button id="btnBackMain" style="display:none">本譜に戻る</button>
        </div>
        <ol id="moves"></ol>
      </div>

    </div>
  </div>

<script>
(() => {
  // ---- Helpers: text decode (cp932/shift-jis)
  function decodeKif(buf) {
    const encs = ["shift-jis", "cp932", "utf-8"];
    for (const enc of encs) {
      try {
        const td = new TextDecoder(enc, { fatal: false });
        const txt = td.decode(buf);
        if (txt && txt.length > 20) return txt;
      } catch (_) {}
    }
    return new TextDecoder("utf-8").decode(buf);
  }

  // ---- Shogi representation
  const PIECE = {
    P:"歩", L:"香", N:"桂", S:"銀", G:"金", B:"角", R:"飛", K:"玉",
    pP:"と", pL:"杏", pN:"圭", pS:"全", pB:"馬", pR:"龍",
  };
  const JP_NUM = "〇一二三四五六七八九十";

  function promote(kind){
    if (kind === "P") return "pP";
    if (kind === "L") return "pL";
    if (kind === "N") return "pN";
    if (kind === "S") return "pS";
    if (kind === "B") return "pB";
    if (kind === "R") return "pR";
    return kind;
  }
  function unpromote(kind){
    if (kind === "pP") return "P";
    if (kind === "pL") return "L";
    if (kind === "pN") return "N";
    if (kind === "pS") return "S";
    if (kind === "pB") return "B";
    if (kind === "pR") return "R";
    return kind;
  }
  function isPromoted(kind){ return kind.startsWith("p"); }

  function emptyBoard() {
    return Array.from({length:10}, () => Array(10).fill(null));
  }

  function initStartpos() {
    const b = emptyBoard();
    const ranks = [
      "lnsgkgsnl",
      "1r5b1",
      "ppppppppp",
      "9",
      "9",
      "9",
      "PPPPPPPPP",
      "1B5R1",
      "LNSGKGSNL",
    ];
    for (let r=1; r<=9; r++){
      const row = ranks[r-1];
      let f = 9;
      for (let i=0; i<row.length; i++){
        const ch = row[i];
        if (/\d/.test(ch)) { f -= Number(ch); continue; }
        const side = (ch === ch.toUpperCase()) ? "b" : "w";
        const pc = ch.toUpperCase();
        const kind = pc === "P" ? "P" :
                     pc === "L" ? "L" :
                     pc === "N" ? "N" :
                     pc === "S" ? "S" :
                     pc === "G" ? "G" :
                     pc === "B" ? "B" :
                     pc === "R" ? "R" : "K";
        b[r][f] = { side, kind };
        f -= 1;
      }
    }
    const hands = { b:{}, w:{} };
    return { board:b, hands, stm:"b", lastTo:null };
  }

  function clonePos(pos){
    const b2 = emptyBoard();
    for (let r=1;r<=9;r++) for (let f=1;f<=9;f++){
      const p = pos.board[r][f];
      b2[r][f] = p ? { side:p.side, kind:p.kind } : null;
    }
    const h2 = { b:{}, w:{} };
    for (const s of ["b","w"]) for (const k in pos.hands[s]) h2[s][k] = pos.hands[s][k];
    return { board:b2, hands:h2, stm:pos.stm, lastTo: pos.lastTo ? { ...pos.lastTo } : null };
  }

  // ---- KIF parsing (main + variations)
  const FW_DIGITS = "０１２３４５６７８９";
  const KAN_RANK = { "一":1,"二":2,"三":3,"四":4,"五":5,"六":6,"七":7,"八":8,"九":9 };

  function parseDest(s, lastTo) {
    s = s.trim();
    if (s.startsWith("同")) {
      if (!lastTo) return null;
      return { f:lastTo.f, r:lastTo.r, rest: s.replace(/^同\s*/, "") };
    }
    const fch = s[0], rch = s[1];
    const f = FW_DIGITS.indexOf(fch);
    const r = KAN_RANK[rch];
    if (!(f>=1 && f<=9 && r>=1 && r<=9)) return null;
    return { f, r, rest: s.slice(2) };
  }

  function parsePieceAndFlags(rest) {
    rest = rest.replace(/\s+/g, "");
    rest = rest.replace(/[▲▼☗☖]/g, ""); // 先後記号が混ざる棋譜用
    let isDrop = rest.includes("打");
    rest = rest.replace(/打/g, "");
    let forceNoProm = rest.includes("不成");
    rest = rest.replace(/不成/g, "");
    rest = rest.replace(/[右左直寄引上行]/g, "");

    const tokens = [
      ["成銀","pS"], ["成桂","pN"], ["成香","pL"], ["成歩","pP"],
      ["と","pP"], ["馬","pB"], ["龍","pR"], ["竜","pR"],
      ["飛","R"], ["角","B"], ["金","G"], ["銀","S"], ["桂","N"], ["香","L"], ["歩","P"], ["玉","K"], ["王","K"],
    ];
    let kind = null;
    for (const [t,k] of tokens){
      if (rest.startsWith(t)) { kind = k; rest = rest.slice(t.length); break; }
    }
    if (!kind) return null;

    let prom = false;
    if (!forceNoProm && rest.startsWith("成")) { prom = true; rest = rest.slice(1); }
    if (forceNoProm) prom = false;
    if (isPromoted(kind)) prom = false;

    return { kind, prom, isDrop };
  }

  const move_pat1 = /^\s*(\d+)\s+(.+?)\((\d\d)\)\s*\(/;
  const move_pat2 = /^\s*(\d+)\s+(.+?)\s*\(/;
  const var_pat   = /^\s*変化：\s*(\d+)\s*手/;

  function parseKifTree(kifText) {
    const lines = kifText.split(/\r?\n/);
    const meta = {};
    let inMoves = false;

    const main = [];
    const varsByMoveNo = new Map(); // key: moveNo(int) => array of variation blocks

    let curVar = null; // { atMoveNo, moves:[] }
    let mainEnded = false;

    function pushVarBlock(v){
      if (!v || !v.moves.length) return;
      if (!varsByMoveNo.has(v.atMoveNo)) varsByMoveNo.set(v.atMoveNo, []);
      varsByMoveNo.get(v.atMoveNo).push(v);
    }

    for (const line0 of lines) {
      const line = line0.trimEnd();
      if (!line) continue;

      if (line.includes("手数----指手")) { inMoves = true; continue; }
      if (!inMoves) {
        const m = line.match(/^([^：]+)：(.*)$/);
        if (m) meta[m[1].trim()] = m[2].trim();
        continue;
      }

      if (line.startsWith("*")) continue;

      const vm = line.match(var_pat);
      if (vm) {
        // start new variation block
        pushVarBlock(curVar);
        curVar = { atMoveNo: Number(vm[1]), moves: [] };
        mainEnded = true;
        continue;
      }

      // match move line
      let m1 = line.match(move_pat1);
      let m2 = line.match(move_pat2);
      if (!m1 && !m2) continue;

      const no = Number((m1||m2)[1]);
      const mvStr = (m1||m2)[2].trim();
      const from = m1 ? m1[3] : null;
      const obj = { no, mvStr, from, raw: line };

      if (!mainEnded && !curVar) {
        main.push(obj);
      } else {
        // in variation section
        if (!curVar) {
          // variation section without explicit header (rare). treat as var from this move
          curVar = { atMoveNo: no, moves: [] };
        }
        curVar.moves.push(obj);
      }
    }
    pushVarBlock(curVar);

    return { meta, main, varsByMoveNo };
  }

  // ---- Move application (same as before, but used lazily)
  function dir(side){ return side === "b" ? -1 : 1; }
  function inside(f,r){ return f>=1 && f<=9 && r>=1 && r<=9; }

  function canReach(board, side, kind, fromF, fromR, toF, toR) {
    const df = toF - fromF;
    const dr = toR - fromR;
    const d = dir(side);

    function clearLine(stepF, stepR) {
      let f = fromF + stepF, r = fromR + stepR;
      while (f !== toF || r !== toR) {
        if (!inside(f,r)) return false;
        if (board[r][f]) return false;
        f += stepF; r += stepR;
      }
      return true;
    }

    if (kind === "pP" || kind === "pL" || kind === "pN" || kind === "pS") {
      return (
        (df===0 && dr===d) ||
        (Math.abs(df)===1 && dr===d) ||
        (Math.abs(df)===1 && dr===0) ||
        (df===0 && dr===-d)
      );
    }

    if (kind === "G") {
      return (
        (df===0 && dr===d) ||
        (Math.abs(df)===1 && dr===d) ||
        (Math.abs(df)===1 && dr===0) ||
        (df===0 && dr===-d)
      );
    }
    if (kind === "S") {
      return (
        (df===0 && dr===d) ||
        (Math.abs(df)===1 && dr===d) ||
        (Math.abs(df)===1 && dr===-d)
      );
    }
    if (kind === "K") return Math.abs(df)<=1 && Math.abs(dr)<=1 && !(df===0 && dr===0);
    if (kind === "P") return df===0 && dr===d;
    if (kind === "N") return (Math.abs(df)===1 && dr===2*d);
    if (kind === "L") {
      if (df!==0) return false;
      if ((toR-fromR)*d <= 0) return false;
      return clearLine(0, d);
    }
    if (kind === "B" || kind === "pB") {
      if (Math.abs(df) === Math.abs(dr) && df!==0) {
        const stepF = df>0?1:-1;
        const stepR = dr>0?1:-1;
        if (!clearLine(stepF, stepR)) return false;
        return true;
      }
      if (kind === "pB") return (Math.abs(df)===1 && dr===0) || (Math.abs(dr)===1 && df===0);
      return false;
    }
    if (kind === "R" || kind === "pR") {
      if ((df===0 && dr!==0) || (dr===0 && df!==0)) {
        const stepF = df===0 ? 0 : (df>0?1:-1);
        const stepR = dr===0 ? 0 : (dr>0?1:-1);
        if (!clearLine(stepF, stepR)) return false;
        return true;
      }
      if (kind === "pR") return Math.abs(df)===1 && Math.abs(dr)===1;
      return false;
    }
    return false;
  }

  function applyMove(pos, mvObj) {
    const next = clonePos(pos);
    const side = next.stm;

    const destParsed = parseDest(mvObj.mvStr, next.lastTo);
    if (!destParsed) return { next, ok:false };

    const { f:toF, r:toR, rest } = destParsed;
    const pf = parsePieceAndFlags(rest);
    if (!pf) return { next, ok:false };

    let { kind, prom, isDrop } = pf;

    const target = next.board[toR][toF];
    if (target && target.side !== side) {
      const capBase = unpromote(target.kind);
      next.hands[side][capBase] = (next.hands[side][capBase] || 0) + 1;
    }

    let fromF = null, fromR = null;
    if (!isDrop && mvObj.from) {
      fromF = Number(mvObj.from[0]);
      fromR = Number(mvObj.from[1]);
    }

    if (isDrop) {
      const base = unpromote(kind);
      if ((next.hands[side][base] || 0) > 0) next.hands[side][base] -= 1;
      next.board[toR][toF] = { side, kind: base };
    } else {
      let piece = null;
      if (fromF && fromR) piece = next.board[fromR][fromF];

      if (!piece || piece.side !== side) {
        const wantBase = unpromote(kind);
        let found = null;
        for (let r=1;r<=9;r++) for (let f=1;f<=9;f++){
          const p = next.board[r][f];
          if (!p || p.side !== side) continue;
          if (unpromote(p.kind) !== wantBase) continue;
          if (canReach(next.board, side, p.kind, f, r, toF, toR)) { found = {f,r,p}; break; }
        }
        if (found) { fromF = found.f; fromR = found.r; piece = found.p; }
        else { piece = { side, kind: wantBase }; fromF = null; fromR = null; }
      }

      if (fromF && fromR) next.board[fromR][fromF] = null;

      let movedKind = piece.kind;
      if (prom) movedKind = promote(unpromote(movedKind));
      next.board[toR][toF] = { side, kind: movedKind };
    }

    next.lastTo = { f:toF, r:toR };
    next.stm = (side === "b") ? "w" : "b";
    return { next, ok:true };
  }

  // ---- UI state
  let kif = null;           // parsed tree
  let lineMoves = [];       // current line (main or selected variation line)
  let curPly = 0;
  let positions = [];       // lazy cache: positions[ply]
  let currentVariation = null; // { atMoveNo, indexInGroup, moves[] } or null

  // elements
  const elBoard = document.getElementById("board");
  const elMoves = document.getElementById("moves");
  const elSlider = document.getElementById("slider");
  const elPlyLabel = document.getElementById("plyLabel");
  const elMoveLabel = document.getElementById("moveLabel");
  const elMeta = document.getElementById("meta");
  const elFile = document.getElementById("file");
  const elKifText = document.getElementById("kifText");
  const elBranchUI = document.getElementById("branchUI");
  const elBranchList = document.getElementById("branchList");
  const elBranchHint = document.getElementById("branchHint");
  const elBtnBackMain = document.getElementById("btnBackMain");

  const elTurnMark = document.getElementById("turnMark");
  const elTurnWho  = document.getElementById("turnWho");
  const elTurnHold = document.getElementById("turnHold");

  const elTopFiles = document.getElementById("topFiles");
  const elRightRanks = document.getElementById("rightRanks");

  function initCoords(){
    elTopFiles.innerHTML = "";
    for (const f of [9,8,7,6,5,4,3,2,1]){
      const d = document.createElement("div");
      d.textContent = String(f);
      elTopFiles.appendChild(d);
    }
    elRightRanks.innerHTML = "";
    const kan = ["一","二","三","四","五","六","七","八","九"];
    for (const k of kan){
      const d = document.createElement("div");
      d.textContent = k;
      elRightRanks.appendChild(d);
    }
  }

  function renderBoard(pos) {
    elBoard.innerHTML = "";
    for (let r=1; r<=9; r++) {
      const tr = document.createElement("tr");
      for (let f=9; f>=1; f--) {
        const td = document.createElement("td");
        const p = pos.board[r][f];
        if (p) {
          const span = document.createElement("span");
          const k = p.kind;
          const base = unpromote(k);
          span.textContent = (isPromoted(k) ? PIECE[k] : PIECE[base]) || "?";
          if (p.side === "w") span.className = "gote";
          td.appendChild(span);
        }
        tr.appendChild(td);
      }
      elBoard.appendChild(tr);
    }
  }

  function fmtHoldLine(hand){
    // 例: 角歩二（歩×2なら「歩二」）
    const order = ["R","B","G","S","N","L","P"];
    let out = "";
    for (const k of order){
      const n = hand[k] || 0;
      if (!n) continue;
      out += PIECE[k];
      if (n >= 2) out += (n < JP_NUM.length ? JP_NUM[n] : String(n));
    }
    return out || "なし";
  }

  function updateTurnBadge(pos){
    const stm = pos.stm; // side to move
    elTurnMark.textContent = (stm === "b") ? "☗" : "☖";
    elTurnWho.textContent  = (stm === "b") ? "先手番" : "後手番";
    const bHold = fmtHoldLine(pos.hands.b);
    const wHold = fmtHoldLine(pos.hands.w);
    elTurnHold.textContent = `先手：${bHold} / 後手：${wHold}`;
  }

  function ensurePos(ply){
    ply = Math.max(0, Math.min(ply, lineMoves.length));
    while (positions.length <= ply){
      const prev = positions[positions.length - 1];
      const mv = lineMoves[positions.length - 1];
      const res = applyMove(prev, mv);
      positions.push(res.next);
    }
    return positions[ply];
  }

  function renderMovelist() {
    elMoves.innerHTML = "";
    lineMoves.forEach((m, idx) => {
      const li = document.createElement("li");
      li.textContent = `${m.no}. ${m.mvStr}${m.from ? " ("+m.from+")" : ""}`;
      li.dataset.ply = String(idx+1);
      li.addEventListener("click", () => setPly(idx+1));
      elMoves.appendChild(li);
    });
  }

  function highlightMovelist() {
    const lis = elMoves.querySelectorAll("li");
    lis.forEach(li => li.classList.remove("active"));
    if (curPly >= 1) {
      const li = elMoves.querySelector(`li[data-ply="${curPly}"]`);
      if (li) {
        li.classList.add("active");
        li.scrollIntoView({ block:"nearest" });
      }
    }
  }

  function setBranchUI(){
    // 変化：N手 は「N手目の手」なので、分岐が選べるのは (N-1)手目の局面
    elBranchList.innerHTML = "";
    elBranchUI.style.display = "none";
    elBtnBackMain.style.display = currentVariation ? "inline-block" : "none";

    if (!kif) return;

    const nextMoveNo = curPly + 1; // これから指す手番号
    const vars = kif.varsByMoveNo.get(nextMoveNo);
    if (!vars || !vars.length) return;

    elBranchUI.style.display = "block";
    elBranchHint.textContent = `「変化：${nextMoveNo}手」からの候補が ${vars.length} 個あります。`;

    vars.forEach((v, idx) => {
      const first = v.moves[0];
      const label = first ? `${first.no}. ${first.mvStr}${first.from ? " ("+first.from+")" : ""}` : `変化 ${idx+1}`;
      const btn = document.createElement("button");
      btn.className = "branchBtn" + (currentVariation && currentVariation.atMoveNo === v.atMoveNo && currentVariation.indexInGroup === idx ? " active" : "");
      btn.textContent = label;
      btn.addEventListener("click", () => {
        selectVariation(nextMoveNo, idx, v);
      });
      elBranchList.appendChild(btn);
    });
  }

  function rebuildLine(){
    // main only or main + selected variation
    if (!kif){
      lineMoves = [];
      return;
    }
    if (!currentVariation){
      lineMoves = kif.main.slice();
      return;
    }
    const atMoveNo = currentVariation.atMoveNo; // N
    const prefix = kif.main.slice(0, atMoveNo - 1); // up to N-1 moves
    lineMoves = prefix.concat(currentVariation.moves);
  }

  function resetPositions(){
    positions = [initStartpos()];
    curPly = 0;
    elSlider.min = "0";
    elSlider.max = String(lineMoves.length);
    elSlider.value = "0";
  }

  function setPly(ply) {
    ply = Math.max(0, Math.min(ply, lineMoves.length));
    curPly = ply;

    elSlider.value = String(ply);
    elPlyLabel.textContent = `${ply}手目`;

    const pos = ensurePos(ply);
    renderBoard(pos);
    updateTurnBadge(pos);
    highlightMovelist();

    if (ply === 0) elMoveLabel.textContent = "初期局面";
    else {
      const m = lineMoves[ply-1];
      elMoveLabel.textContent = `${m.no}. ${m.mvStr}${m.from ? " ("+m.from+")" : ""}`;
    }
    setBranchUI();
  }

  function setMeta(meta) {
    const keys = ["棋戦","戦型","開始日時","終了日時","手合割","先手","後手"];
    let out = "";
    for (const k of keys) if (meta[k]) out += `${k}：${meta[k]}\n`;
    elMeta.textContent = out.trim();
  }

  function loadKifText(text) {
    kif = parseKifTree(text);
    setMeta(kif.meta);

    currentVariation = null;
    rebuildLine();
    renderMovelist();
    resetPositions();
    setPly(0);
  }

  function selectVariation(atMoveNo, indexInGroup, varBlock){
    currentVariation = { atMoveNo, indexInGroup, moves: varBlock.moves.slice() };
    rebuildLine();
    renderMovelist();
    resetPositions();
    // 分岐開始直前へ移動
    setPly(atMoveNo - 1);
  }

  // buttons
  document.getElementById("btnFirst").addEventListener("click", () => setPly(0));
  document.getElementById("btnPrev").addEventListener("click", () => setPly(curPly-1));
  document.getElementById("btnNext").addEventListener("click", () => setPly(curPly+1));
  document.getElementById("btnLast").addEventListener("click", () => setPly(lineMoves.length));

  elSlider.addEventListener("input", (e) => setPly(Number(e.target.value)));

  document.getElementById("btnReset").addEventListener("click", () => {
    if (!kif){
      kif = { meta:{}, main:[], varsByMoveNo:new Map() };
      lineMoves = [];
      renderMovelist();
    }
    currentVariation = null;
    rebuildLine();
    renderMovelist();
    resetPositions();
    setPly(0);
  });

  document.getElementById("btnLoadText").addEventListener("click", () => {
    const t = elKifText.value;
    if (!t.trim()) return;
    loadKifText(t);
  });

  elFile.addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const buf = await f.arrayBuffer();
    const text = decodeKif(buf);
    elKifText.value = text;
    loadKifText(text);
  });

  document.getElementById("btnSample").addEventListener("click", async () => {
    try {
      const res = await fetch("./piyo_prev_game.kif", { cache: "no-store" });
      if (!res.ok) throw new Error("fetch failed");
      const buf = await res.arrayBuffer();
      const text = decodeKif(buf);
      elKifText.value = text;
      loadKifText(text);
    } catch (e) {
      alert("サンプルが見つかりません。piyo_prev_game.kif を同じ場所に置いてください。");
    }
  });

  elBtnBackMain.addEventListener("click", () => {
    currentVariation = null;
    rebuildLine();
    renderMovelist();
    resetPositions();
    setPly(0);
  });

  // initial
  initCoords();
  kif = null;
  lineMoves = [];
  positions = [initStartpos()];
  renderBoard(positions[0]);
  updateTurnBadge(positions[0]);
})();
</script>
</body>
</html>
