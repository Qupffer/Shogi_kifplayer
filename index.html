<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>KIF Viewer (branches)</title>
  <style>
    :root{
      --sq: min(46px, 8.2vw);
      --wood: #d6b27a;
      --wood2:#c79d63;
      --line:#3b2a16;
      --line2:#5a3f21;
      --panel:#ffffff;
      --ink:#1b1b1b;
      --muted:#666;
      --badge:#ffe6a8;
    }
    html, body { height: 100%; }
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Hiragino Sans", "Noto Sans JP", "Segoe UI", sans-serif;
      margin: 0;
      color: var(--ink);
      background: #f6f4ef;
    }
    header{
      padding: 14px 14px 8px;
    }
    h1{
      margin: 0;
      font-size: 18px;
      font-weight: 800;
    }
    .wrap{
      padding: 0 14px 14px;
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    .panel{
      background: var(--panel);
      border: 1px solid #e3e3e3;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.03);
    }
    .controls{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    button{
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #c9c9c9;
      background: #fff;
      cursor: pointer;
      font-weight: 700;
    }
    button:active{ transform: translateY(1px); }
    input[type="range"]{ width: min(560px, 92vw); }
    textarea{
      width: min(720px, 92vw);
      height: 140px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      line-height: 1.35;
    }
    .meta{
      font-size: 12px;
      color: #444;
      white-space: pre-wrap;
      margin-top: 10px;
    }

    /* ======= stage (hands left/right) ======= */
    .stage{
      display: grid;
      grid-template-columns: minmax(110px, 160px) auto minmax(110px, 160px);
      gap: 10px;
      align-items: center;
      justify-content: start;
      overflow-x: auto;
      padding-bottom: 4px;
    }
    .handbox{
      display: grid;
      gap: 8px;
      align-content: start;
      min-width: 110px;
    }
    .handtitle{
      font-weight: 900;
      color: #222;
      font-size: 13px;
      letter-spacing: 0.02em;
      opacity: 0.95;
    }
    .handgrid{
      display: grid;
      grid-template-columns: repeat(2, minmax(48px, 1fr));
      gap: 6px;
    }
    .chip{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid #e3dfd7;
      background: #fffaf0;
      font-family: "Hiragino Mincho ProN", "Yu Mincho", "Noto Serif JP", serif;
      font-weight: 800;
    }
    .chip .p{ font-size: 16px; }
    .chip .n{
      font-family: -apple-system, BlinkMacSystemFont, "Hiragino Sans", "Noto Sans JP", "Segoe UI", sans-serif;
      font-weight: 900;
      font-size: 12px;
      color: #333;
      opacity: 0.9;
    }
    .handempty{
      font-size: 12px;
      color: var(--muted);
    }

    .boardwrap{
      display: grid;
      justify-items: center;
      gap: 10px;
    }

    table.board{
      border-collapse: collapse;
      user-select: none;
      background: linear-gradient(180deg, var(--wood), var(--wood2));
      border: 2px solid var(--line);
      box-shadow: 0 6px 18px rgba(0,0,0,0.10);
    }
    table.board td{
      width: var(--sq);
      height: var(--sq);
      border: 1px solid rgba(59,42,22,0.75);
      text-align: center;
      vertical-align: middle;
      position: relative;
      font-size: 20px;
      font-family: "Hiragino Mincho ProN", "Yu Mincho", "Noto Serif JP", serif;
      font-weight: 900;
      color: #1d1208;
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
    }
    table.board td::after{
      content:"";
      position:absolute;
      inset: 0;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
      pointer-events:none;
    }
    .gote{
      display:inline-block;
      transform: rotate(180deg);
    }

    .navrow{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
    }
    .small{ font-size: 12px; color: var(--muted); }

    .movelist{
      max-height: min(52vh, calc(var(--sq) * 10 + 120px));
      overflow: auto;
    }
    .movelist ol{ margin: 0; padding-left: 22px; }
    .movelist li{
      padding: 4px 8px;
      border-radius: 10px;
      cursor: pointer;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 8px;
    }
    .movelist li:hover{ background: #f2f2f2; }
    .movelist li.active{ background: #e8f0ff; }
    .badge{
      font-size: 11px;
      font-weight: 900;
      background: var(--badge);
      border: 1px solid #e2c97a;
      padding: 2px 8px;
      border-radius: 999px;
      color: #4a320f;
      white-space: nowrap;
    }

    .branchpanel{
      display:grid;
      gap: 8px;
    }
    .branchbuttons{
      display:flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items:center;
    }
    .branchbuttons button{
      padding: 7px 10px;
      border-radius: 999px;
      font-weight: 900;
    }
    .branchbuttons button.active{
      border-color:#5274ff;
      box-shadow: 0 0 0 2px rgba(82,116,255,0.18);
    }

    /* wide layout */
    @media (min-width: 980px){
      .wrap{
        grid-template-columns: 1.15fr 1fr;
        align-items: start;
      }
    }
  </style>
</head>
<body>
<header>
  <h1>簡易 棋譜再生（KIF / 分岐対応）</h1>
</header>

<div class="wrap">
  <div class="panel">
    <div class="controls">
      <!-- iOSで選べなくなる問題を避けるため accept を絞らない -->
      <input id="file" type="file" accept="*/*" />
      <button id="btnSample" title="同じリポジトリに piyo_prev_game.kif を置いた場合">サンプル読込</button>
      <button id="btnReset">初期局面</button>
    </div>
    <div style="margin-top:10px">
      <div class="small">ファイルが面倒なら、ここにKIFを貼って「貼付読込」でもOK。</div>
      <textarea id="kifText" placeholder="ここにKIFを貼り付け"></textarea>
      <div class="controls" style="margin-top:8px">
        <button id="btnLoadText">貼付読込</button>
      </div>
    </div>
    <div class="meta" id="meta"></div>
  </div>

  <div class="panel">
    <div class="stage">
      <!-- Left (後手 上寄り) -->
      <div class="handbox" style="align-self:start" id="handW">
        <div class="handtitle">後手 持ち駒</div>
        <div class="handgrid" id="handWGrid"></div>
        <div class="handempty" id="handWEmpty" style="display:none">なし</div>
      </div>

      <!-- Center board -->
      <div class="boardwrap">
        <table class="board" id="board"></table>

        <div class="navrow">
          <button id="btnFirst">|&lt;</button>
          <button id="btnPrev">&lt;</button>
          <button id="btnNext">&gt;</button>
          <button id="btnLast">&gt;|</button>
        </div>

        <div class="navrow">
          <input id="slider" type="range" min="0" max="0" value="0" />
          <span id="plyLabel" class="small">0手目</span>
        </div>
        <div class="small" id="moveLabel"></div>
      </div>

      <!-- Right (先手 下寄り) -->
      <div class="handbox" style="align-self:end" id="handB">
        <div class="handtitle">先手 持ち駒</div>
        <div class="handgrid" id="handBGrid"></div>
        <div class="handempty" id="handBEmpty" style="display:none">なし</div>
      </div>
    </div>

    <div class="branchpanel" style="margin-top:10px">
      <div class="small" id="branchLabel">分岐：なし</div>
      <div class="branchbuttons" id="branchBtns"></div>
    </div>

    <div class="movelist" style="margin-top:12px">
      <div class="small" style="margin-bottom:6px">手順（タップで移動）</div>
      <ol id="moves"></ol>
    </div>
  </div>
</div>

<script>
(() => {
  // ---- Helpers: text decode (cp932/shift-jis)
  function decodeKif(buf) {
    const encs = ["shift-jis", "cp932", "utf-8"];
    for (const enc of encs) {
      try {
        const td = new TextDecoder(enc, { fatal: false });
        const txt = td.decode(buf);
        if (txt && txt.length > 20) return txt;
      } catch (_) {}
    }
    return new TextDecoder("utf-8").decode(buf);
  }

  // ---- Shogi representation
  const PIECE = {
    P:"歩", L:"香", N:"桂", S:"銀", G:"金", B:"角", R:"飛", K:"玉",
    pP:"と", pL:"杏", pN:"圭", pS:"全", pB:"馬", pR:"龍",
  };
  function promote(kind){
    if (kind === "P") return "pP";
    if (kind === "L") return "pL";
    if (kind === "N") return "pN";
    if (kind === "S") return "pS";
    if (kind === "B") return "pB";
    if (kind === "R") return "pR";
    return kind;
  }
  function unpromote(kind){
    if (kind === "pP") return "P";
    if (kind === "pL") return "L";
    if (kind === "pN") return "N";
    if (kind === "pS") return "S";
    if (kind === "pB") return "B";
    if (kind === "pR") return "R";
    return kind;
  }
  function isPromoted(kind){ return kind.startsWith("p"); }

  function emptyBoard() {
    return Array.from({length:10}, () => Array(10).fill(null));
  }

  function initStartpos() {
    const b = emptyBoard();
    const ranks = [
      "lnsgkgsnl",
      "1r5b1",
      "ppppppppp",
      "9",
      "9",
      "9",
      "PPPPPPPPP",
      "1B5R1",
      "LNSGKGSNL",
    ];
    for (let r=1; r<=9; r++){
      const row = ranks[r-1];
      let f = 9;
      for (let i=0; i<row.length; i++){
        const ch = row[i];
        if (/\d/.test(ch)) { f -= Number(ch); continue; }
        const side = (ch === ch.toUpperCase()) ? "b" : "w";
        const pc = ch.toUpperCase();
        const kind =
          pc === "P" ? "P" :
          pc === "L" ? "L" :
          pc === "N" ? "N" :
          pc === "S" ? "S" :
          pc === "G" ? "G" :
          pc === "B" ? "B" :
          pc === "R" ? "R" : "K";
        b[r][f] = { side, kind };
        f -= 1;
      }
    }
    const hands = { b:{}, w:{} };
    return { board:b, hands, stm:"b", lastTo:null };
  }

  function clonePos(pos){
    const b2 = emptyBoard();
    for (let r=1;r<=9;r++) for (let f=1;f<=9;f++){
      const p = pos.board[r][f];
      b2[r][f] = p ? { side:p.side, kind:p.kind } : null;
    }
    const h2 = { b:{}, w:{} };
    for (const s of ["b","w"]) {
      for (const k in pos.hands[s]) h2[s][k] = pos.hands[s][k];
    }
    return { board:b2, hands:h2, stm:pos.stm, lastTo: pos.lastTo ? { ...pos.lastTo } : null };
  }

  // ---- KIF parsing (with branches)
  const FW_DIGITS = "０１２３４５６７８９";
  const KAN_RANK = { "一":1,"二":2,"三":3,"四":4,"五":5,"六":6,"七":7,"八":8,"九":9 };

  function parseDest(s, lastTo) {
    s = s.trim();
    if (s.startsWith("同")) {
      if (!lastTo) return null;
      return { f:lastTo.f, r:lastTo.r, rest: s.replace(/^同\s*/, "") };
    }
    const fch = s[0], rch = s[1];
    const f = FW_DIGITS.indexOf(fch);
    const r = KAN_RANK[rch];
    if (!(f>=1 && f<=9 && r>=1 && r<=9)) return null;
    return { f, r, rest: s.slice(2) };
  }

  function parsePieceAndFlags(rest) {
    rest = rest.replace(/\s+/g, "");
    let isDrop = rest.includes("打");
    rest = rest.replace(/打/g, "");
    let forceNoProm = rest.includes("不成");
    rest = rest.replace(/不成/g, "");
    rest = rest.replace(/[右左直寄引上行]/g, "");

    const tokens = [
      ["成銀","pS"], ["成桂","pN"], ["成香","pL"], ["成歩","pP"],
      ["と","pP"], ["馬","pB"], ["龍","pR"], ["竜","pR"],
      ["飛","R"], ["角","B"], ["金","G"], ["銀","S"], ["桂","N"], ["香","L"], ["歩","P"], ["玉","K"], ["王","K"],
    ];
    let kind = null;
    for (const [t,k] of tokens){
      if (rest.startsWith(t)) { kind = k; rest = rest.slice(t.length); break; }
    }
    if (!kind) return null;

    let prom = false;
    if (!forceNoProm && rest.startsWith("成")) { prom = true; rest = rest.slice(1); }
    if (forceNoProm) prom = false;
    if (isPromoted(kind)) prom = false;

    return { kind, prom, isDrop };
  }

  // Node tree
  let NODE_ID = 1;
  function mkNode(moveObj=null){
    return { id: NODE_ID++, move: moveObj, children: [] };
  }

  // move line parser (ゆるめ)
  // 例:
  //  11 ８七歩打 ( 0:01/00:00:06)
  //   1 ２六歩(27)( 0:01/00:00:01)
  //   1 ２六歩 (27) ( 0:01/00:00:01)
  function parseMoveLine(line) {
    const mNo = line.match(/^\s*(\d+)\s+(.*)$/);
    if (!mNo) return null;
    const no = Number(mNo[1]);
    let rest = mNo[2].trim();

    // 終局系
    if (/^(投了|中断|千日手|持将棋|詰み|反則勝ち|反則負け)/.test(rest)) {
      return { no, mvStr: rest, from: null, raw: line, terminal:true };
    }

    // 先に時間部分を落とす（最後の括弧から始まることが多い）
    // ただし (27) を残したいので「時刻っぽい括弧」だけ落とす
    rest = rest.replace(/\(\s*\d+\s*:\s*\d+.*\)\s*$/g, "").trim();

    // 元座標 (27) を拾う（スペース入りも許容）
    let from = null;
    // "...(27)" または "... ( 2 7 )"
    const mFrom = rest.match(/\(\s*([1-9])\s*([1-9])\s*\)\s*$/);
    if (mFrom) {
      from = `${mFrom[1]}${mFrom[2]}`;
      rest = rest.replace(/\(\s*([1-9])\s*([1-9])\s*\)\s*$/,"").trim();
    }

    // move string は残り
    const mvStr = rest;
    if (!mvStr) return null;

    return { no, mvStr, from, raw: line, terminal:false };
  }

  function parseKifWithBranches(kifText) {
    const lines = kifText.split(/\r?\n/);
    const meta = {};
    const mainMoves = [];
    const variations = []; // { startNo, moves: [] }

    let inMoves = false;
    let currentVar = null;

    function flushVar(){
      if (currentVar && currentVar.moves.length) variations.push(currentVar);
      currentVar = null;
    }

    for (const line0 of lines) {
      const line = line0.trimEnd();
      if (!line) continue;

      if (line.includes("手数----指手")) { inMoves = true; continue; }
      if (!inMoves) {
        const m = line.match(/^([^：]+)：(.*)$/);
        if (m) meta[m[1].trim()] = m[2].trim();
        continue;
      }

      if (line.startsWith("*")) continue;

      // 変化：xx手
      const mv = line.match(/^変化[:：]\s*(\d+)\s*手/);
      if (mv) {
        flushVar();
        currentVar = { startNo: Number(mv[1]), moves: [] };
        continue;
      }

      const mo = parseMoveLine(line);
      if (!mo) continue;

      if (currentVar) {
        currentVar.moves.push(mo);
      } else {
        mainMoves.push(mo);
      }
    }
    flushVar();

    // build tree: root -> main line as first child chain
    NODE_ID = 1;
    const root = mkNode(null);
    let cur = root;
    for (const m of mainMoves) {
      const nn = mkNode(m);
      cur.children.push(nn);
      cur = nn;
      if (m.terminal) break;
    }

    // attach variations
    // variation startNo means "変化：N手" = after (N-1) moves position, next move is Nth
    for (const v of variations) {
      const startPly = Math.max(0, v.startNo - 1);
      // walk mainline nodes to reach node at startPly
      let node = root;
      let ply = 0;
      while (ply < startPly && node.children.length) {
        node = node.children[0];
        ply++;
      }
      // now attach sequence as an additional child path starting from node
      let attachPoint = node;
      for (let i=0; i<v.moves.length; i++) {
        const m = v.moves[i];
        const nn = mkNode(m);
        attachPoint.children.push(nn); // important: push as sibling choice at that ply (first move in var)
        attachPoint = nn;
        if (m.terminal) break;
        // for deeper moves in the variation, they become the single chain (as "main" of that var)
        // so we keep attaching as first child only
        if (i < v.moves.length - 1) {
          // next loop will add to attachPoint.children, but should be the only child chain
          // we handle by continuing normally and always pushing to children of current node
        }
      }
    }

    return { meta, root };
  }

  // ---- Move application (same tolerance approach)
  function dir(side){ return side === "b" ? -1 : 1; }
  function inside(f,r){ return f>=1 && f<=9 && r>=1 && r<=9; }

  function canReach(board, side, kind, fromF, fromR, toF, toR) {
    const df = toF - fromF;
    const dr = toR - fromR;
    const d = dir(side);

    function clearLine(stepF, stepR) {
      let f = fromF + stepF, r = fromR + stepR;
      while (f !== toF || r !== toR) {
        if (!inside(f,r)) return false;
        if (board[r][f]) return false;
        f += stepF; r += stepR;
      }
      return true;
    }

    if (kind === "pP" || kind === "pL" || kind === "pN" || kind === "pS") {
      return (
        (df===0 && dr===d) ||
        (Math.abs(df)===1 && dr===d) ||
        (Math.abs(df)===1 && dr===0) ||
        (df===0 && dr===-d)
      );
    }

    if (kind === "G") {
      return (
        (df===0 && dr===d) ||
        (Math.abs(df)===1 && dr===d) ||
        (Math.abs(df)===1 && dr===0) ||
        (df===0 && dr===-d)
      );
    }
    if (kind === "S") {
      return (
        (df===0 && dr===d) ||
        (Math.abs(df)===1 && dr===d) ||
        (Math.abs(df)===1 && dr===-d)
      );
    }
    if (kind === "K") return Math.abs(df)<=1 && Math.abs(dr)<=1 && !(df===0 && dr===0);
    if (kind === "P") return df===0 && dr===d;
    if (kind === "N") return (Math.abs(df)===1 && dr===2*d);
    if (kind === "L") {
      if (df!==0) return false;
      if ((toR-fromR)*d <= 0) return false;
      return clearLine(0, d);
    }
    if (kind === "B" || kind === "pB") {
      if (Math.abs(df) === Math.abs(dr) && df!==0) {
        const stepF = df>0?1:-1;
        const stepR = dr>0?1:-1;
        if (!clearLine(stepF, stepR)) return false;
        return true;
      }
      if (kind === "pB") return (Math.abs(df)===1 && dr===0) || (Math.abs(dr)===1 && df===0);
      return false;
    }
    if (kind === "R" || kind === "pR") {
      if ((df===0 && dr!==0) || (dr===0 && df!==0)) {
        const stepF = df===0 ? 0 : (df>0?1:-1);
        const stepR = dr===0 ? 0 : (dr>0?1:-1);
        if (!clearLine(stepF, stepR)) return false;
        return true;
      }
      if (kind === "pR") return Math.abs(df)===1 && Math.abs(dr)===1;
      return false;
    }
    return false;
  }

  function applyMove(pos, mvObj) {
    const next = clonePos(pos);
    const side = next.stm;

    if (mvObj.terminal) {
      // 終局は局面を変えない（表示だけ進めるためOK扱い）
      next.stm = (side === "b") ? "w" : "b";
      return { next, ok:true };
    }

    const destParsed = parseDest(mvObj.mvStr, next.lastTo);
    if (!destParsed) return { next, ok:false };
    const { f:toF, r:toR, rest } = destParsed;

    const pf = parsePieceAndFlags(rest);
    if (!pf) return { next, ok:false };

    let { kind, prom, isDrop } = pf;

    // capture
    const target = next.board[toR][toF];
    if (target && target.side !== side) {
      const capBase = unpromote(target.kind);
      next.hands[side][capBase] = (next.hands[side][capBase] || 0) + 1;
    }

    let fromF = null, fromR = null;
    if (!isDrop && mvObj.from) {
      fromF = Number(mvObj.from[0]);
      fromR = Number(mvObj.from[1]);
    }

    if (isDrop) {
      const base = unpromote(kind);
      if ((next.hands[side][base] || 0) > 0) next.hands[side][base] -= 1;
      next.board[toR][toF] = { side, kind: base };
    } else {
      let piece = null;
      if (fromF && fromR) piece = next.board[fromR][fromF];

      if (!piece || piece.side !== side) {
        const wantBase = unpromote(kind);
        let found = null;
        for (let r=1;r<=9;r++) for (let f=1;f<=9;f++){
          const p = next.board[r][f];
          if (!p || p.side !== side) continue;
          if (unpromote(p.kind) !== wantBase) continue;
          if (canReach(next.board, side, p.kind, f, r, toF, toR)) { found = {f,r,p}; break; }
        }
        if (found) { fromF = found.f; fromR = found.r; piece = found.p; }
        else { piece = { side, kind: wantBase }; fromF = null; fromR = null; }
      }

      if (fromF && fromR) next.board[fromR][fromF] = null;

      let movedKind = piece.kind;
      if (prom) movedKind = promote(unpromote(movedKind));
      next.board[toR][toF] = { side, kind: movedKind };
    }

    next.lastTo = { f:toF, r:toR };
    next.stm = (side === "b") ? "w" : "b";
    return { next, ok:true };
  }

  // ---- UI / state
  let kif = null;            // { meta, root }
  let choiceById = {};       // node.id -> child index
  let lineNodes = [];        // nodes along selected line (ply1..)
  let positions = [];        // positions[ply]
  let curPly = 0;

  const elBoard = document.getElementById("board");
  const elMoves = document.getElementById("moves");
  const elSlider = document.getElementById("slider");
  const elPlyLabel = document.getElementById("plyLabel");
  const elMoveLabel = document.getElementById("moveLabel");
  const elMeta = document.getElementById("meta");
  const elFile = document.getElementById("file");
  const elKifText = document.getElementById("kifText");

  const elHandWGrid = document.getElementById("handWGrid");
  const elHandBGrid = document.getElementById("handBGrid");
  const elHandWEmpty = document.getElementById("handWEmpty");
  const elHandBEmpty = document.getElementById("handBEmpty");

  const elBranchLabel = document.getElementById("branchLabel");
  const elBranchBtns  = document.getElementById("branchBtns");

  function renderBoard(pos) {
    elBoard.innerHTML = "";
    for (let r=1; r<=9; r++) {
      const tr = document.createElement("tr");
      for (let f=9; f>=1; f--) {
        const td = document.createElement("td");
        const p = pos.board[r][f];
        if (p) {
          const span = document.createElement("span");
          const k = p.kind;
          const base = unpromote(k);
          const label = (isPromoted(k) ? PIECE[k] : PIECE[base]) || "?";
          span.textContent = label;
          if (p.side === "w") span.className = "gote";
          td.appendChild(span);
        }
        tr.appendChild(td);
      }
      elBoard.appendChild(tr);
    }
  }

  function renderHands(pos) {
    function fillGrid(side, gridEl, emptyEl){
      const order = ["R","B","G","S","N","L","P"];
      gridEl.innerHTML = "";
      let any = false;
      for (const k of order) {
        const n = pos.hands[side][k] || 0;
        if (n <= 0) continue;
        any = true;
        const d = document.createElement("div");
        d.className = "chip";
        d.innerHTML = `<span class="p">${PIECE[k]}</span><span class="n">${n}</span>`;
        gridEl.appendChild(d);
      }
      emptyEl.style.display = any ? "none" : "block";
    }
    fillGrid("w", elHandWGrid, elHandWEmpty);
    fillGrid("b", elHandBGrid, elHandBEmpty);
  }

  function nodeAtPly(ply){
    // ply 0: root, ply>=1: lineNodes[ply-1]
    if (!kif) return null;
    if (ply === 0) return kif.root;
    return lineNodes[ply-1] || null;
  }

  function buildSelectedLine() {
    lineNodes = [];
    let node = kif.root;
    while (node.children.length) {
      const idx = (choiceById[node.id] ?? 0);
      const next = node.children[Math.max(0, Math.min(idx, node.children.length-1))];
      lineNodes.push(next);
      node = next;
      if (next.move && next.move.terminal) break;
    }
  }

  function buildPositions() {
    buildSelectedLine();
    positions = [];
    let pos = initStartpos();
    positions.push(clonePos(pos));
    for (let i=0; i<lineNodes.length; i++) {
      const mv = lineNodes[i].move;
      const res = applyMove(pos, mv);
      pos = res.next;
      positions.push(clonePos(pos));
    }
    elSlider.max = String(Math.max(0, positions.length-1));
    if (curPly > positions.length-1) curPly = positions.length-1;
  }

  function renderMovelist() {
    elMoves.innerHTML = "";
    for (let i=0; i<lineNodes.length; i++) {
      const node = lineNodes[i];
      const m = node.move;
      const li = document.createElement("li");
      li.dataset.ply = String(i+1);
      const hasBranch = (nodeAtPly(i).children.length >= 2); // choices at parent ply
      const badge = hasBranch ? `<span class="badge">分岐</span>` : "";
      li.innerHTML = `<span>${m.no}. ${m.mvStr}${m.from ? " ("+m.from+")" : ""}</span>${badge}`;
      li.addEventListener("click", () => setPly(i+1));
      elMoves.appendChild(li);
    }
  }

  function highlightMovelist() {
    const lis = elMoves.querySelectorAll("li");
    lis.forEach(li => li.classList.remove("active"));
    if (curPly >= 1) {
      const li = elMoves.querySelector(`li[data-ply="${curPly}"]`);
      if (li) {
        li.classList.add("active");
        li.scrollIntoView({ block:"nearest" });
      }
    }
  }

  function renderBranchPanel() {
    const parent = nodeAtPly(curPly); // at current ply, choose next from here
    if (!parent) {
      elBranchLabel.textContent = "分岐：なし";
      elBranchBtns.innerHTML = "";
      return;
    }
    const kids = parent.children || [];
    if (kids.length <= 1) {
      elBranchLabel.textContent = "分岐：なし";
      elBranchBtns.innerHTML = "";
      return;
    }
    elBranchLabel.textContent = `分岐：この局面から ${kids.length} 手の候補`;
    elBranchBtns.innerHTML = "";
    const activeIdx = (choiceById[parent.id] ?? 0);
    kids.forEach((ch, idx) => {
      const b = document.createElement("button");
      b.textContent = ch.move ? ch.move.mvStr : `(??)`;
      if (idx === activeIdx) b.classList.add("active");
      b.addEventListener("click", () => {
        choiceById[parent.id] = idx;
        const keep = curPly; // keep current ply
        rebuildAll();
        setPly(keep);
      });
      elBranchBtns.appendChild(b);
    });
  }

  function setPly(ply) {
    ply = Math.max(0, Math.min(ply, positions.length-1));
    curPly = ply;
    elSlider.value = String(ply);
    elPlyLabel.textContent = `${ply}手目`;

    const pos = positions[ply];
    renderBoard(pos);
    renderHands(pos);
    highlightMovelist();
    renderBranchPanel();

    if (!kif) {
      elMoveLabel.textContent = "初期局面";
      return;
    }
    if (ply === 0) {
      elMoveLabel.textContent = "初期局面";
    } else {
      const node = lineNodes[ply-1];
      const m = node.move;
      elMoveLabel.textContent = `${m.no}. ${m.mvStr}${m.from ? " ("+m.from+")" : ""}`;
    }
  }

  function setMeta(meta) {
    const keys = ["棋戦","戦型","開始日時","終了日時","手合割","先手","後手"];
    let out = "";
    for (const k of keys) if (meta[k]) out += `${k}：${meta[k]}\n`;
    elMeta.textContent = out.trim();
  }

  function rebuildAll() {
    if (!kif) return;
    buildPositions();
    renderMovelist();
  }

  function loadKifText(text) {
    kif = parseKifWithBranches(text);
    choiceById = {}; // reset choices
    setMeta(kif.meta);
    curPly = 0;
    rebuildAll();
    setPly(0);
  }

  // buttons
  document.getElementById("btnFirst").addEventListener("click", () => setPly(0));
  document.getElementById("btnPrev").addEventListener("click", () => setPly(curPly-1));
  document.getElementById("btnNext").addEventListener("click", () => setPly(curPly+1));
  document.getElementById("btnLast").addEventListener("click", () => setPly(positions.length-1));

  elSlider.addEventListener("input", (e) => setPly(Number(e.target.value)));

  document.getElementById("btnReset").addEventListener("click", () => {
    // keep loaded kif, just go to start
    setPly(0);
  });

  document.getElementById("btnLoadText").addEventListener("click", () => {
    const t = elKifText.value;
    if (!t.trim()) return;
    loadKifText(t);
  });

  elFile.addEventListener("change", async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    const buf = await f.arrayBuffer();
    const text = decodeKif(buf);
    elKifText.value = text;
    loadKifText(text);
  });

  document.getElementById("btnSample").addEventListener("click", async () => {
    try {
      const res = await fetch("./piyo_prev_game.kif", { cache: "no-store" });
      if (!res.ok) throw new Error("fetch failed");
      const buf = await res.arrayBuffer();
      const text = decodeKif(buf);
      elKifText.value = text;
      loadKifText(text);
    } catch (e) {
      alert("サンプルが見つからないわ。リポジトリ直下に piyo_prev_game.kif を置いてね。");
    }
  });

  // initial render
  kif = null;
  positions = [initStartpos()];
  renderBoard(positions[0]);
  renderHands(positions[0]);
  renderBranchPanel();
})();
</script>
</body>
</html>
